import { NextResponse } from "next/server"
import { createClient } from "@/lib/supabase/server"
import { createClient as createServiceClient } from "@supabase/supabase-js"
import {
  validateProjectId,
  validateHeaders,
  securityLog,
  isSuspiciousUserAgent,
} from "@/lib/validation"

// Helper to base64-encode UTF-8 text
function toBase64(str) {
  return Buffer.from(str, "utf8").toString("base64")
}

// Helper to create GitHub repo
async function createGithubRepo(githubToken, repoName, description) {
  const response = await fetch("https://api.github.com/user/repos", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${githubToken}`,
      Accept: "application/vnd.github+json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      name: repoName,
      description: description || "Chrome extension generated by chromie",
      private: true,
      auto_init: false,
    }),
  })

  const data = await response.json()

  if (!response.ok) {
    const baseMessage = data?.message || "Failed to create GitHub repository"
    const errorDetails = Array.isArray(data?.errors) && data.errors.length > 0
      ? ` Details: ${JSON.stringify(data.errors)}`
      : ""
    throw new Error(`GitHub: ${baseMessage}${errorDetails}`)
  }

  return data
}

// Helper to create/update a file in GitHub repo
async function upsertGithubFile({
  githubToken,
  owner,
  repo,
  filePath,
  contentBase64,
  commitMessage,
  sha,
  branch,
}) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(
    filePath
  )}`

  const response = await fetch(url, {
    method: "PUT",
    headers: {
      Authorization: `Bearer ${githubToken}`,
      Accept: "application/vnd.github+json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      message: commitMessage,
      content: contentBase64,
      ...(sha ? { sha } : {}),
      ...(branch ? { branch } : {}),
    }),
  })

  const data = await response.json()

  if (!response.ok) {
    const baseMessage = data?.message || `Failed to create file ${filePath} in GitHub repository`
    const errorDetails = Array.isArray(data?.errors) && data.errors.length > 0
      ? ` Details: ${JSON.stringify(data.errors)}`
      : ""
    throw new Error(`GitHub: ${baseMessage}${errorDetails}`)
  }

  return data
}

export async function POST(request, { params }) {
  const startTime = Date.now()
  const supabase = createClient()
  const { id: projectId } = params

  const userAgent = request.headers.get("user-agent") || "unknown"
  const clientIP =
    request.headers.get("x-forwarded-for") ||
    request.headers.get("x-real-ip") ||
    "unknown"

  securityLog("info", "GitHub export request received", {
    projectId,
    userAgent,
    clientIP,
  })

  // Basic header validation
  const headerValidation = validateHeaders(request.headers)
  if (!headerValidation.isValid) {
    return NextResponse.json(
      { error: headerValidation.error },
      { status: 400 }
    )
  }

  // Validate project ID format
  const projectValidation = validateProjectId(projectId)
  if (!projectValidation.isValid) {
    securityLog("warn", "Invalid project ID for GitHub export", {
      projectId,
      error: projectValidation.error,
      userAgent,
      clientIP,
    })
    return NextResponse.json(
      { error: projectValidation.error },
      { status: 400 }
    )
  }

  // Basic user agent screening
  if (isSuspiciousUserAgent(userAgent)) {
    securityLog("warn", "Suspicious user agent blocked for GitHub export", {
      userAgent,
      clientIP,
      projectId,
    })
    return NextResponse.json({ error: "Invalid request" }, { status: 400 })
  }

  try {
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser()

    if (userError || !user) {
      securityLog("warn", "Unauthorized GitHub export attempt", {
        projectId,
        userAgent,
        clientIP,
        error: userError?.message,
      })
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    // Load user's stored GitHub token
    const { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("github_access_token")
      .eq("id", user.id)
      .maybeSingle()

    if (profileError) {
      console.error("[github-export] Failed to load profile:", profileError)
      return NextResponse.json(
        { error: "Failed to load GitHub connection status" },
        { status: 500 }
      )
    }

    const githubToken = profile?.github_access_token

    if (!githubToken) {
      return NextResponse.json(
        { error: "GitHub account not connected. Please connect GitHub from your profile page first." },
        { status: 400 }
      )
    }

    // Optional body: allow passing a custom repo name
    let requestedRepoName
    try {
      const body = await request.json()
      requestedRepoName = body?.repoName
    } catch {
      requestedRepoName = undefined
    }

    // Verify project ownership and fetch project details
    const { data: project, error: projectError } = await supabase
      .from("projects")
      .select("id, name, description, github_repo_full_name, github_repo_url")
      .eq("id", projectId)
      .eq("user_id", user.id)
      .single()

    if (projectError || !project) {
      return NextResponse.json(
        { error: "Project not found or unauthorized" },
        { status: 404 }
      )
    }

    // Fetch project files from RLS-protected table
    const { data: files, error: filesError } = await supabase
      .from("code_files")
      .select("file_path, content")
      .eq("project_id", projectId)
      .order("file_path")

    if (filesError) {
      console.error("[github-export] Error fetching project files:", filesError)
      return NextResponse.json(
        { error: "Failed to fetch project files" },
        { status: 500 }
      )
    }

    if (!files || files.length === 0) {
      return NextResponse.json(
        { error: "No files found for this project" },
        { status: 404 }
      )
    }

    // Parse manifest to determine required icons, similar to shared download route
    const manifestFile = files.find((f) => f.file_path === "manifest.json")
    if (!manifestFile) {
      return NextResponse.json(
        { error: "Manifest file not found in project" },
        { status: 400 }
      )
    }

    let manifest
    try {
      manifest = JSON.parse(manifestFile.content)
    } catch (e) {
      return NextResponse.json(
        { error: "Invalid manifest.json content" },
        { status: 400 }
      )
    }

    // Ensure icons structure is present
    if (!manifest.icons || typeof manifest.icons !== "object" || Array.isArray(manifest.icons)) {
      manifest.icons = {}
    }
    if (!manifest.icons["16"]) manifest.icons["16"] = "icons/icon16.png"
    if (!manifest.icons["48"]) manifest.icons["48"] = "icons/icon48.png"
    if (!manifest.icons["128"]) manifest.icons["128"] = "icons/icon128.png"

    if (manifest.action) {
      if (
        !manifest.action.default_icon ||
        typeof manifest.action.default_icon !== "object" ||
        Array.isArray(manifest.action.default_icon)
      ) {
        manifest.action.default_icon = {}
      }
      if (!manifest.action.default_icon["16"])
        manifest.action.default_icon["16"] = "icons/icon16.png"
      if (!manifest.action.default_icon["48"])
        manifest.action.default_icon["48"] = "icons/icon48.png"
      if (!manifest.action.default_icon["128"])
        manifest.action.default_icon["128"] = "icons/icon128.png"
    }

    // Collect required icon paths
    const requiredIconPaths = new Set()

    for (const p of Object.values(manifest.icons || {})) {
      if (typeof p === "string" && p.startsWith("icons/")) requiredIconPaths.add(p)
    }

    if (manifest.action && manifest.action.default_icon) {
      for (const p of Object.values(manifest.action.default_icon)) {
        if (typeof p === "string" && p.startsWith("icons/")) requiredIconPaths.add(p)
      }
    }

    const iconRefRegex = /icons\/[A-Za-z0-9-_]+\.png/gi
    for (const f of files) {
      if (typeof f.content !== "string") continue
      if (f.file_path.startsWith("icons/")) continue
      const matches = f.content.match(iconRefRegex)
      if (matches) {
        for (const m of matches) {
          const p = m.startsWith("icons/") ? m : `icons/${m}`
          requiredIconPaths.add(p)
        }
      }
    }

    const iconPaths = Array.from(requiredIconPaths)
    console.log("[github-export] required icon paths", iconPaths)

    // Fetch icons from shared_icons via service role (same pattern as shared download)
    const SUPABASE_URL = process.env.SUPABASE_URL
    const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY

    let iconFiles = []

    if (iconPaths.length > 0) {
      if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
        return NextResponse.json(
          {
            error:
              "Server configuration error: missing Supabase service credentials for icons",
          },
          { status: 500 }
        )
      }

      const serviceSupabase = createServiceClient(
        SUPABASE_URL,
        SUPABASE_SERVICE_ROLE_KEY,
        {
          auth: { persistSession: false },
        }
      )

      const { data: iconRows, error: iconError } = await serviceSupabase
        .from("shared_icons")
        .select("path_hint, content_base64")
        .in("path_hint", iconPaths)
        .eq("visibility", "global")

      if (iconError) {
        console.error(
          "[github-export] Failed to fetch shared icons from Supabase:",
          iconError
        )
        return NextResponse.json(
          { error: "Failed to fetch icons from shared store" },
          { status: 500 }
        )
      }

      const iconMap = new Map((iconRows || []).map((r) => [r.path_hint, r]))
      const missing = iconPaths.filter((p) => !iconMap.has(p))

      if (missing.length > 0) {
        console.error("[github-export] Missing required icons:", missing)
        return NextResponse.json(
          {
            error: `Missing required icons: ${missing.join(
              ", "
            )}. Please contact support.`,
          },
          { status: 400 }
        )
      }

      iconFiles = iconPaths.map((iconPath) => {
        const row = iconMap.get(iconPath)
        return {
          file_path: iconPath,
          content_base64: row.content_base64,
        }
      })
    }

    // Determine whether to create a new repo or sync to an existing one
    let repo
    let ownerLogin
    let targetRepoName
    let defaultBranch = "main"

    if (project.github_repo_full_name) {
      // Sync mode: push changes to existing repo
      const [ownerPart, repoPart] = project.github_repo_full_name.split("/")
      if (!ownerPart || !repoPart) {
        throw new Error(
          `GitHub: Invalid stored repository mapping '${project.github_repo_full_name}'. Please disconnect and reconnect GitHub or contact support.`
        )
      }

      const repoResponse = await fetch(
        `https://api.github.com/repos/${ownerPart}/${repoPart}`,
        {
          headers: {
            Authorization: `Bearer ${githubToken}`,
            Accept: "application/vnd.github+json",
          },
        }
      )

      const repoData = await repoResponse.json()

      if (!repoResponse.ok) {
        const baseMessage = repoData?.message || "Failed to access existing GitHub repository"
        throw new Error(`GitHub: ${baseMessage}`)
      }

      repo = repoData
      ownerLogin = repo.owner?.login || ownerPart
      targetRepoName = repo.name
      defaultBranch = repo.default_branch || "main"
    } else {
      // First-time export: create a new repo
      const safeProjectName = project.name
        .replace(/[^a-zA-Z0-9-_]/g, "-")
        .toLowerCase()
      const repoName = (requestedRepoName || safeProjectName || "chromie-extension")
        .trim()
        .slice(0, 100)

      repo = await createGithubRepo(
        githubToken,
        repoName,
        project.description
      )

      ownerLogin = repo?.owner?.login
      if (!ownerLogin) {
        throw new Error("Failed to determine GitHub repository owner")
      }

      targetRepoName = repo.name
      defaultBranch = repo.default_branch || "main"
    }

    // Commit all project files (text files)
    for (const file of files) {
      if (!file.file_path || typeof file.content === "undefined") continue

      let sha = undefined

      // When syncing, fetch existing file SHA so GitHub treats this as an update
      if (project.github_repo_full_name) {
        const existingResponse = await fetch(
          `https://api.github.com/repos/${ownerLogin}/${targetRepoName}/contents/${encodeURIComponent(
            file.file_path
          )}?ref=${encodeURIComponent(defaultBranch)}`,
          {
            headers: {
              Authorization: `Bearer ${githubToken}`,
              Accept: "application/vnd.github+json",
            },
          }
        )

        if (existingResponse.ok) {
          const existingData = await existingResponse.json()
          sha = existingData?.sha
        }
      }

      const commitMessage = project.github_repo_full_name
        ? `Update ${file.file_path} from chromie project`
        : `Add ${file.file_path} from chromie project`

      const contentBase64 = toBase64(String(file.content))

      await upsertGithubFile({
        githubToken,
        owner: ownerLogin,
        repo: targetRepoName,
        filePath: file.file_path,
        contentBase64,
        commitMessage,
        sha,
        branch: defaultBranch,
      })
    }

    // Commit icon files (binary content already base64-encoded in DB)
    for (const icon of iconFiles) {
      let sha = undefined

      if (project.github_repo_full_name) {
        const existingResponse = await fetch(
          `https://api.github.com/repos/${ownerLogin}/${targetRepoName}/contents/${encodeURIComponent(
            icon.file_path
          )}?ref=${encodeURIComponent(defaultBranch)}`,
          {
            headers: {
              Authorization: `Bearer ${githubToken}`,
              Accept: "application/vnd.github+json",
            },
          }
        )

        if (existingResponse.ok) {
          const existingData = await existingResponse.json()
          sha = existingData?.sha
        }
      }

      const commitMessage = project.github_repo_full_name
        ? `Update ${icon.file_path} icon from shared icon store`
        : `Add ${icon.file_path} icon from shared icon store`

      await upsertGithubFile({
        githubToken,
        owner: ownerLogin,
        repo: targetRepoName,
        filePath: icon.file_path,
        contentBase64: icon.content_base64,
        commitMessage,
        sha,
        branch: defaultBranch,
      })
    }

    // Persist GitHub mapping on the project for future syncs
    if (repo?.full_name && repo?.html_url) {
      try {
        await supabase
          .from("projects")
          .update({
            github_repo_full_name: repo.full_name,
            github_repo_url: repo.html_url,
          })
          .eq("id", projectId)
          .eq("user_id", user.id)
      } catch (updateError) {
        console.error("[github-export] Failed to update project with GitHub mapping:", updateError)
        // Non-fatal; continue
      }
    }

    const processingTime = Date.now() - startTime

    securityLog("info", "GitHub export completed successfully", {
      userId: user.id,
      projectId,
      repoFullName: repo.full_name,
      htmlUrl: repo.html_url,
      processingTime,
      userAgent,
      clientIP,
    })

    return NextResponse.json({
      success: true,
      repo: {
        full_name: repo.full_name,
        html_url: repo.html_url,
        name: repo.name,
        owner: repo.owner?.login,
      },
    })
  } catch (error) {
    const processingTime = Date.now() - startTime

    securityLog("error", "GitHub export failed", {
      projectId,
      error: error.message,
      stack: error.stack,
      processingTime,
      userAgent,
      clientIP,
    })

    console.error("[github-export] Error exporting project to GitHub:", error)

    const status =
      error.message && error.message.toLowerCase().includes("github")
        ? 502
        : 500

    return NextResponse.json(
      { error: error.message || "Failed to export project to GitHub" },
      { status }
    )
  }
}


