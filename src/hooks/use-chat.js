"use client"

import { useState, useRef, useEffect } from "react"
import { replaceOrAddMessage, continueGenerationWithUrl } from "@/components/ui/chat-utils"

export function useChat({ 
  projectId, 
  autoGeneratePrompt, 
  onAutoGenerateComplete, 
  onCodeGenerated, 
  onGenerationStart, 
  onGenerationEnd, 
  isProjectReady 
}) {
  const [messages, setMessages] = useState([
    {
      role: "assistant",
      content: "hi! i'm **chromie**, your chrome extension assistant. tell me what you'd like in your extension.",
    },
  ])
  const [inputMessage, setInputMessage] = useState("")
  const [isGenerating, setIsGenerating] = useState(false)
  const [hasGeneratedCode, setHasGeneratedCode] = useState(false)
  const messagesEndRef = useRef(null)
  const autoGeneratedPrompts = useRef(new Set()) // Track prompts that have been auto-generated

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }

  useEffect(() => {
    scrollToBottom()
  }, [messages])

  // Fetch hasGeneratedCode status from Supabase when project changes
  useEffect(() => {
    if (projectId) {
      const fetchHasGeneratedCode = async () => {
        try {
          const response = await fetch(`/api/projects/${projectId}/has-generated-code`)
          
          if (response.ok) {
            const data = await response.json()
            console.log(`🔍 hasGeneratedCode loaded from Supabase: ${data.hasGeneratedCode}`)
            setHasGeneratedCode(data.hasGeneratedCode)
          } else {
            console.warn(`⚠️ Failed to fetch hasGeneratedCode status: ${response.status}`)
            setHasGeneratedCode(false)
          }
        } catch (error) {
          console.error('Error fetching hasGeneratedCode status:', error)
          setHasGeneratedCode(false)
        }
      }
      
      fetchHasGeneratedCode()
    }
  }, [projectId])

  // Auto-generate when autoGeneratePrompt is provided (from homepage redirect)
  useEffect(() => {
    console.log('🎯 Auto-generation effect triggered:', {
      autoGeneratePrompt,
      isProjectReady,
      isGenerating,
      hasBeenProcessed: autoGeneratedPrompts.current.has(autoGeneratePrompt),
      projectId
    })
    
    if (autoGeneratePrompt && isProjectReady && !isGenerating && !autoGeneratedPrompts.current.has(autoGeneratePrompt)) {
      console.log('🚀 Auto-generating from homepage prompt:', autoGeneratePrompt, 'for project:', projectId)
      
      // Mark this prompt as being processed
      autoGeneratedPrompts.current.add(autoGeneratePrompt)
      
      // Add the user message to chat only once
      const userMessage = { role: "user", content: autoGeneratePrompt }
      setMessages(prev => replaceOrAddMessage(prev, userMessage))
      
      // Trigger generation automatically
      handleAutoGeneration(autoGeneratePrompt)
    } else if (autoGeneratePrompt && !isProjectReady) {
      console.log('⏳ Auto-generate prompt waiting for project to be ready:', autoGeneratePrompt)
    } else if (autoGeneratePrompt && isGenerating) {
      console.log('⏳ Auto-generate prompt waiting for current generation to complete:', autoGeneratePrompt)
    } else if (autoGeneratedPrompts.current.has(autoGeneratePrompt)) {
      console.log('✅ Auto-generate prompt already processed:', autoGeneratePrompt)
    } else if (!autoGeneratePrompt) {
      console.log('📝 No auto-generate prompt to process')
    }
  }, [autoGeneratePrompt, isProjectReady, isGenerating, projectId])

  const handleSendMessage = async (e) => {
    e.preventDefault()
    if (!inputMessage.trim() || isGenerating) return

    // Check if we have a valid project ID
    if (!isProjectReady) {
      const errorMessage = {
        role: "assistant",
        content: "please wait while i set up your project, then try again.",
      }
      setMessages((prev) => [...prev, errorMessage])
      return
    }

    const userMessage = { role: "user", content: inputMessage }
    setMessages((prev) => [...prev, userMessage])
    setInputMessage("")
    setIsGenerating(true)

    // Notify parent component that generation started
    if (onGenerationStart) {
      onGenerationStart()
    }

    try {
      console.log("Sending request with type:", hasGeneratedCode ? "add_to_existing" : "new_extension")
      
      const response = await fetch("/api/generate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt: inputMessage,
          projectId,
          requestType: hasGeneratedCode ? "add_to_existing" : "new_extension",
        }),
      })

      const data = await response.json()

      let content = ""

      // Handle different response scenarios
      if (response.status === 403) {
        content = data.error || "token usage limit exceeded for your plan. please upgrade to continue generating extensions."
      } else if (data.requiresUrl) {
        // Show URL prompt modal for scraping - no chat message needed
        console.log('🔗 URL required for scraping - showing modal only');
        
        // Ensure spinner is not shown
        setIsGenerating(false)
        
        // Clear the auto-generate prompt for URL requests
        if (onAutoGenerateComplete) {
          onAutoGenerateComplete()
        }
        
        return; // Don't continue with normal flow
      } else if (data.explanation) {
        content = `${data.explanation}`
      } else if (data.error) {
        content = `Error: ${data.error}`
      } else {
        content = "code generated successfully!"
      }

      // Only add "generating code..." message if we're actually generating code (not showing URL modal)
      if (content && !data.requiresUrl) {
        setIsGenerating(true)
        const generatingMessage = {
          role: "assistant",
          content: "🚀 generating code...",
        }
        setMessages(prev => replaceOrAddMessage(prev, generatingMessage))
        
        // Create the final assistant message
        const assistantMessage = {
          role: "assistant",
          content,
        }

        // Replace the "generating code..." message with the actual result
        setMessages((prev) => {
          const newMessages = [...prev]
          // Replace the last message (which should be the "generating code..." message)
          if (newMessages.length > 0 && newMessages[newMessages.length - 1].content.includes("Generating code")) {
            newMessages[newMessages.length - 1] = assistantMessage
          } else {
            newMessages.push(assistantMessage)
          }
          return newMessages
        })

        // Mark that code has been generated
        setHasGeneratedCode(true)

        if (onCodeGenerated) {
          onCodeGenerated(data)
        }

        // Refresh token usage display by triggering a page reload of the token usage component
        // This is a simple way to refresh the token usage without complex state management
        const tokenUsageEvent = new CustomEvent('tokenUsageUpdated')
        window.dispatchEvent(tokenUsageEvent)
      }
    } catch (error) {
      console.error("Error generating code:", error)
      const errorMessage = {
        role: "assistant",
        content: "sorry, i encountered an error while generating your extension. please try again.",
      }
      
      // Replace the "generating code..." message with the error message
      setMessages((prev) => {
        const newMessages = [...prev]
        // Replace the last message (which should be the "generating code..." message)
        if (newMessages.length > 0 && newMessages[newMessages.length - 1].content.includes("Generating code")) {
          newMessages[newMessages.length - 1] = errorMessage
        } else {
          newMessages.push(errorMessage)
        }
        return newMessages
      })
    } finally {
      // Do not force spinner on; keep whatever state was set above
      // Notify parent component that generation ended
      if (onGenerationEnd) {
        onGenerationEnd()
      }
    }
  }

  // Handle auto-generation from homepage redirect
  const handleAutoGeneration = async (prompt) => {
    console.log('🎯 handleAutoGeneration called with prompt:', prompt, 'projectReady:', isProjectReady)
    
    if (!isProjectReady) {
      console.log('❌ Project not ready, cannot auto-generate')
      const errorMessage = {
        role: "assistant",
        content: "please wait while i set up your project, then try again.",
      }
      setMessages((prev) => [...prev, errorMessage])
      return
    }

    console.log('✅ Project ready, starting auto-generation for prompt:', prompt)
    setIsGenerating(true)

    // Notify parent component that generation started
    if (onGenerationStart) {
      onGenerationStart()
    }

    try {
      console.log("🚀 Auto-generating with prompt:", prompt, "for project:", projectId)
      
      const response = await fetch("/api/generate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt: prompt,
          projectId,
          requestType: hasGeneratedCode ? "add_to_existing" : "new_extension",
        }),
      })

      const data = await response.json()

      let content = ""

      // Handle different response scenarios
      if (response.status === 403) {
        content = data.error || "token usage limit exceeded for your plan. please upgrade to continue generating extensions."
      } else if (data.requiresUrl) {
        // Show URL prompt modal for scraping - no chat message needed
        console.log('🔗 URL required for scraping - showing modal only');
        
        // Ensure spinner is not shown
        setIsGenerating(false)
        
        // Emit event so AIChat opens the modal immediately in auto flow
        const urlPromptEvent = new CustomEvent('urlPromptRequired', {
          detail: { data, originalPrompt: prompt }
        })
        window.dispatchEvent(urlPromptEvent)
        
        // Clear the auto-generate prompt for URL requests
        if (onAutoGenerateComplete) {
          onAutoGenerateComplete()
        }
        
        return; // Don't continue with normal flow
      } else if (data.explanation) {
        content = `${data.explanation}`
      } else if (data.error) {
        content = `Error: ${data.error}`
      } else {
        content = "code generated successfully!"
      }

      // Only add "generating code..." message if we're actually generating code (not showing URL modal)
      if (content && !data.requiresUrl) {
        setIsGenerating(true)
        
        const generatingMessage = {
          role: "assistant",
          content: "🚀 generating code...",
        }
        setMessages(prev => replaceOrAddMessage(prev, generatingMessage))
        
        const assistantMessage = {
          role: "assistant",
          content,
        }

        // Replace the "generating code..." message with the actual result
        setMessages((prev) => {
          const newMessages = [...prev]
          // Replace the last message (which should be the "generating code..." message)
          if (newMessages.length > 0 && newMessages[newMessages.length - 1].content.includes("Generating code")) {
            newMessages[newMessages.length - 1] = assistantMessage
          } else {
            newMessages.push(assistantMessage)
          }
          return newMessages
        })

        // Mark that code has been generated
        setHasGeneratedCode(true)

        if (onCodeGenerated) {
          onCodeGenerated(data)
        }

        // Clear the auto-generate prompt after successful generation
        if (onAutoGenerateComplete) {
          console.log('✅ Auto-generation completed successfully, calling onAutoGenerateComplete')
          onAutoGenerateComplete()
        }

        // Refresh token usage display
        const tokenUsageEvent = new CustomEvent('tokenUsageUpdated')
        window.dispatchEvent(tokenUsageEvent)
        
      }
    } catch (error) {
      console.error("Error during auto-generation:", error)
      const errorMessage = {
        role: "assistant",
        content: "sorry, i encountered an error while generating your extension. please try again.",
      }
      
      // Replace the "generating code..." message with the error message
      setMessages((prev) => {
        const newMessages = [...prev]
        // Replace the last message (which should be the "generating code..." message)
        if (newMessages.length > 0 && newMessages[newMessages.length - 1].content.includes("Generating code")) {
          newMessages[newMessages.length - 1] = errorMessage
        } else {
          newMessages.push(errorMessage)
        }
        return newMessages
      })
    } finally {
      // Do not force spinner on; keep whatever state was set above
      
      // Clear the auto-generate prompt even on error
      if (onAutoGenerateComplete) {
        console.log('🔄 Auto-generation finished (success or error), calling onAutoGenerateComplete')
        onAutoGenerateComplete()
      }
      
      // Notify parent component that generation ended
      if (onGenerationEnd) {
        onGenerationEnd()
      }
    }
  }

  // Handle URL submission from modal
  const handleUrlSubmit = (data, userUrl, originalPrompt) => {
    continueGenerationWithUrl(
      data, 
      userUrl, 
      originalPrompt, 
      projectId, 
      hasGeneratedCode, 
      onCodeGenerated, 
      onGenerationEnd,
      setMessages,
      setIsGenerating
    )
  }

  // Handle URL modal cancellation
  const handleUrlCancel = () => {
    const cancelMessage = {
      role: "assistant",
      content: "url request cancelled. extension will be generated without specific website analysis.",
    }
    setMessages((prev) => [...prev, cancelMessage])
    setIsGenerating(false)
  }

  return {
    messages,
    setMessages,
    inputMessage,
    setInputMessage,
    isGenerating,
    setIsGenerating,
    hasGeneratedCode,
    setHasGeneratedCode,
    messagesEndRef,
    handleSendMessage,
    handleUrlSubmit,
    handleUrlCancel,
    scrollToBottom
  }
} 