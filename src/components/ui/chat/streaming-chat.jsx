"use client"

import { useEffect } from "react"
import { FileCode, ChevronDown, ChevronRight, Trash2 } from "lucide-react"
import { AIInputWithSearch } from "@/components/ui/ai-input-with-search"
import TokenUsageAlert from "@/components/ui/modals/token-usage-alert"
import ChatMessage from "@/components/ui/chat/chat-message"
import { ChatBubble, ChatBubbleMessage, ChatBubbleAvatar } from "@/components/ui/chat-bubble"
import { Conversation, ConversationContent, ConversationScrollButton } from "@/components/ui/conversation"
import { useChatState } from "./hooks/useChatState"
import { useStreamProcessor } from "./hooks/useStreamProcessor"
import { cn } from "@/lib/utils"

export default function StreamingChat({
  projectId,
  projectName,
  autoGeneratePrompt,
  onAutoGenerateComplete,
  onCodeGenerated,
  onGenerationStart,
  onGenerationEnd,
  onOpenCanvas,
  hasGeneratedCode: hasGeneratedCodeProp,
  isCanvasOpen,
  chatWidth,
  isProjectReady,
  isOnboardingModalOpen,
  modelOverride,
  onCodeGenerationStarting,
}) {
  const chatState = useChatState(projectId, hasGeneratedCodeProp)
  const {
    inputMessage,
    setInputMessage,
    messages,
    setMessages,
    isGenerating,
    effectiveHasGeneratedCode,
    showTokenLimitModal,
    setShowTokenLimitModal,
    autoGeneratedRef,
    currentRequestRef,
    lastUrlSelectionRef,
    hasGeneratedCode,
    isModelThinkingOpen,
    setIsModelThinkingOpen,
    modelThinkingDisplay,
    modelThinkingFull,
    isGenerationComplete,
    thinkingChunkCountRef,
    planningProgress,
    currentPlanningPhase,
    isActuallyGeneratingCode,
    clearConversation,
  } = chatState

  const { startGeneration, startGenerationWithUrl, continueGenerationWithSkipScraping, continueGenerationWithApis } =
    useStreamProcessor({
      chatState,
      projectId,
      modelOverride,
      isOnboardingModalOpen,
      onGenerationStart,
      onGenerationEnd,
      onCodeGenerated,
      onAutoGenerateComplete,
      autoGeneratePrompt,
    })

  // Auto-generation effect
  useEffect(() => {
    if (
      autoGeneratePrompt &&
      isProjectReady &&
      !hasGeneratedCode &&
      !isGenerating &&
      !autoGeneratedRef.current
    ) {
      autoGeneratedRef.current = true
      setInputMessage(autoGeneratePrompt)

      const userMessage = {
        role: "user",
        content: autoGeneratePrompt,
      }
      setMessages((prev) => [...prev, userMessage])
      startGeneration(autoGeneratePrompt, true)
    }
  }, [autoGeneratePrompt, isProjectReady, hasGeneratedCode, isGenerating])

  // Notify parent when actual code generation starts
  useEffect(() => {
    if (isActuallyGeneratingCode && onCodeGenerationStarting) {
      onCodeGenerationStarting()
    }
  }, [isActuallyGeneratingCode, onCodeGenerationStarting])

  // Note: URL and API prompts are now handled as chat messages, not modals

  const handleSendMessage = async (value, withSearch, images) => {
    if ((!value.trim() && (!images || images.length === 0)) || isGenerating) return

    const userMessage = {
      role: "user",
      content: value,
      images: images || [],
    }

    setMessages((prev) => [...prev, userMessage])
    setInputMessage("")
    await startGeneration(value, false, images)
  }

  const handleUrlSubmit = async (userUrl) => {
    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      const skipScrapingSelection = userUrl === null
      lastUrlSelectionRef.current = {
        userUrl,
        skipScraping: skipScrapingSelection,
      }
    }

    currentRequestRef.current = null

    if (requestInfo) {
      if (userUrl === null) {
        await continueGenerationWithSkipScraping(requestInfo)
      } else {
        await startGenerationWithUrl(
          requestInfo.prompt,
          userUrl,
          requestInfo.requestType,
          requestInfo.projectId,
          requestInfo.analysisData
        )
      }
    }
  }

  const handleUrlCancel = () => {
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
    lastUrlSelectionRef.current = null
  }

  const handleApiSubmit = async (userApis) => {
    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      await continueGenerationWithApis(requestInfo, userApis)
      currentRequestRef.current = null
    }
  }

  const handleApiCancel = () => {
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
  }

  const handleClearConversation = async () => {
    await clearConversation()
  }

  return (
    <div className="flex flex-col h-full relative">
      {/* Chat Header */}
      <div className="pt-4 pb-2 px-8 max-w-7xl mx-auto w-full flex items-center justify-between">
        <p className="text-sm text-gray-200 font-bold">{projectName || "describe what you want to add or modify"}</p>
        {messages.length > 1 && !isGenerating && (
          <button
            onClick={handleClearConversation}
            className="flex items-center space-x-1.5 px-3 py-1.5 text-xs text-gray-400 hover:text-white hover:bg-gray-800/50 rounded-lg transition-colors"
            title="Clear conversation (keeps code)"
          >
            <Trash2 className="h-3.5 w-3.5" />
            <span>clear chat</span>
          </button>
        )}
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-hidden pb-4">
        <Conversation>
          <ConversationContent smooth={true} className="custom-scrollbar">
            {messages
              .filter((message) => !message.isThinking)
              .map((message, index, filteredMessages) => {
                // Show avatar only on first AI message in succession
                const prevMessage = index > 0 ? filteredMessages[index - 1] : null
                const showAvatar = message.role === "assistant" &&
                  (!prevMessage || prevMessage.role !== "assistant")

                return (
                  <ChatMessage
                    key={index}
                    message={message}
                    index={index}
                    showAvatar={showAvatar}
                    typingCancelSignal={chatState.typingCancelSignal}
                    onUrlSubmit={handleUrlSubmit}
                    onApiSubmit={handleApiSubmit}
                    onUrlCancel={handleUrlCancel}
                    onApiCancel={handleApiCancel}
                    setMessages={setMessages}
                    projectId={projectId}
                    onRevert={() => {
                      // Reload the page to refresh the code canvas with reverted files
                      if (typeof window !== 'undefined') {
                        window.location.reload()
                      }
                    }}
                  />
                )
              })}

            {/* Typing indicator */}
            {isGenerating && !(planningProgress && currentPlanningPhase) && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received" isLoading />
              </ChatBubble>
            )}

            {/* Planning progress */}
            {planningProgress && currentPlanningPhase && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center space-x-3">
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-slate-300 rounded-full animate-pulse"
                        style={{ animationDelay: "200ms" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"
                        style={{ animationDelay: "400ms" }}
                      ></div>
                    </div>
                    <div className="flex flex-col">
                      <span className="text-xs text-slate-300 uppercase tracking-wide">
                        {currentPlanningPhase === "analysis" && "Planning"}
                        {currentPlanningPhase === "documentation" && "Documentation"}
                        {currentPlanningPhase === "scraping" && "Web Analysis"}
                        {!["analysis", "documentation", "scraping"].includes(currentPlanningPhase) && "Planning"}
                      </span>
                      <span className="text-sm text-white font-medium">{planningProgress}</span>
                    </div>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}

            {/* Model Thinking Panel */}
            {(() => {
              const hasContent = !!(modelThinkingDisplay || modelThinkingFull)
              const forceShow = thinkingChunkCountRef.current > 0
              const shouldShow = (hasContent || forceShow) && !isGenerationComplete
              return shouldShow
            })() && (
              <div className="mt-2">
                <button
                  type="button"
                  className="flex items-center justify-between w-full text-left text-xs uppercase tracking-wide text-slate-300 bg-slate-800/40 hover:bg-slate-800/60 border border-slate-600/40 px-3 py-2 rounded"
                  onClick={() => setIsModelThinkingOpen(!isModelThinkingOpen)}
                  aria-expanded={isModelThinkingOpen}
                >
                  <span>Model thoughts ({thinkingChunkCountRef.current} chunks)</span>
                  {isModelThinkingOpen ? (
                    <ChevronDown className="h-3 w-3" />
                  ) : (
                    <ChevronRight className="h-3 w-3" />
                  )}
                </button>
                {isModelThinkingOpen && (
                  <div className="mt-2 p-3 rounded-lg border border-slate-500/20 bg-slate-800/20 text-white text-sm whitespace-pre-wrap leading-relaxed max-h-48 overflow-auto italic">
                    {modelThinkingDisplay || modelThinkingFull}
                  </div>
                )}
              </div>
            )}

            {/* Open Canvas Button */}
            {effectiveHasGeneratedCode && onOpenCanvas && !isGenerating && !isCanvasOpen && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center justify-between gap-4">
                    <div className="flex items-center gap-3 flex-1 min-w-0">
                      <div className="flex-shrink-0 w-8 h-8 rounded-lg bg-blue-600 flex items-center justify-center">
                        <FileCode className="h-4 w-4 text-white" />
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-white truncate">
                          {projectName || "Chrome Extension"}
                        </div>
                        <div className="text-xs text-slate-400">Code generated successfully</div>
                      </div>
                    </div>
                    <button
                      id="tour-open-canvas-button"
                      onClick={() => onOpenCanvas()}
                      className="flex-shrink-0 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg"
                    >
                      Open
                    </button>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>
      </div>

      {/* Input at bottom */}
      <div className="px-4 pb-6 pt-4">
        <div className={cn(
          "w-full max-w-4xl mx-auto",
          isCanvasOpen ? "pl-[16.67%]" : ""
        )}>
          <AIInputWithSearch
            placeholder={
              projectName
                ? `describe what you want to add or modify in ${projectName}...`
                : "describe what you want to add or modify..."
            }
            value={inputMessage}
            onChange={(value) => setInputMessage(value)}
            onSubmit={async (value, withSearch, images) => await handleSendMessage(value, withSearch, images)}
            disabled={isGenerating || !projectId}
            className="py-0"
            enableImageUpload={effectiveHasGeneratedCode}
          />
        </div>
      </div>

      {/* Token Usage Alert Modal */}
      <TokenUsageAlert isOpen={showTokenLimitModal} onClose={() => setShowTokenLimitModal(false)} />
    </div>
  )
}
