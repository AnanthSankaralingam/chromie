"use client"

import { useEffect, useState, useRef } from "react"
import { FileCode, ChevronDown, ChevronRight, Trash2 } from "lucide-react"
import { AIInputWithSearch } from "@/components/ui/ai-input-with-search"
import TokenUsageAlert from "@/components/ui/modals/token-usage-alert"
import ClearChatSuggestionModal from "@/components/ui/modals/clear-chat-suggestion-modal"
import ChatMessage from "@/components/ui/chat/chat-message"
import { ChatBubble, ChatBubbleMessage, ChatBubbleAvatar } from "@/components/ui/chat-bubble"
import { Conversation, ConversationContent, ConversationScrollButton } from "@/components/ui/conversation"
import { useChatState } from "./hooks/useChatState"
import { useStreamProcessor } from "./hooks/useStreamProcessor"
import { cn } from "@/lib/utils"
import LogsAppendButton from "@/components/ui/chat/logs-append-button"
import { formatLogsForContext } from "@/lib/utils/console-logs-context"

export default function StreamingChat({
  projectId,
  projectName,
  autoGeneratePrompt,
  onAutoGenerateComplete,
  onCodeGenerated,
  onGenerationStart,
  onGenerationEnd,
  onOpenCanvas,
  hasGeneratedCode: hasGeneratedCodeProp,
  isCanvasOpen,
  chatWidth,
  isProjectReady,
  isOnboardingModalOpen,
  modelOverride,
  onCodeGenerationStarting,
  onSetInputMessage,
  testSessionLogs,
  onClearTestSessionLogs,
  flatFiles,
}) {
  const chatState = useChatState(projectId, hasGeneratedCodeProp)
  const {
    inputMessage,
    setInputMessage,
    messages,
    setMessages,
    isGenerating,
    effectiveHasGeneratedCode,
    showTokenLimitModal,
    setShowTokenLimitModal,
    autoGeneratedRef,
    currentRequestRef,
    lastUrlSelectionRef,
    hasGeneratedCode,
    isModelThinkingOpen,
    setIsModelThinkingOpen,
    modelThinkingDisplay,
    modelThinkingFull,
    isGenerationComplete,
    thinkingChunkCountRef,
    planningProgress,
    currentPlanningPhase,
    isActuallyGeneratingCode,
    clearConversation,
  } = chatState

  // Local mode for follow-up interactions once code exists: "agent" (default) vs "ask"
  const [followUpMode, setFollowUpMode] = useState("agent") // "agent" | "ask"

  // State for clear chat suggestion modal
  const [showClearChatSuggestion, setShowClearChatSuggestion] = useState(false)

  // State to track if logs have been appended
  const [logsAppended, setLogsAppended] = useState(false)

  // Refs for auto-scrolling to AI message start
  const messagesContainerRef = useRef(null)
  const lastAssistantMessageCountRef = useRef(0)

  const { startGeneration, startGenerationWithUrl, continueGenerationWithSkipScraping, continueGenerationWithApis } =
    useStreamProcessor({
      chatState,
      projectId,
      modelOverride,
      isOnboardingModalOpen,
      onGenerationStart,
      onGenerationEnd,
      onCodeGenerated,
      onAutoGenerateComplete,
      autoGeneratePrompt,
    })

  // Auto-generation effect
  useEffect(() => {
    if (
      autoGeneratePrompt &&
      isProjectReady &&
      !hasGeneratedCode &&
      !isGenerating &&
      !autoGeneratedRef.current
    ) {
      autoGeneratedRef.current = true
      setInputMessage(autoGeneratePrompt)

      const userMessage = {
        role: "user",
        content: autoGeneratePrompt,
      }
      setMessages((prev) => [...prev, userMessage])
      startGeneration(autoGeneratePrompt, true)
    }
  }, [autoGeneratePrompt, isProjectReady, hasGeneratedCode, isGenerating])

  // Notify parent when actual code generation starts
  useEffect(() => {
    if (isActuallyGeneratingCode && onCodeGenerationStarting) {
      onCodeGenerationStarting()
    }
  }, [isActuallyGeneratingCode, onCodeGenerationStarting])

  // Expose setInputMessage to parent component
  useEffect(() => {
    if (onSetInputMessage) {
      onSetInputMessage(setInputMessage)
    }
  }, [onSetInputMessage, setInputMessage])

  // Reset append state when new logs arrive
  useEffect(() => {
    if (testSessionLogs) {
      setLogsAppended(false)
    }
  }, [testSessionLogs])

  // Reset logsAppended if logs are removed from input message
  useEffect(() => {
    if (logsAppended && testSessionLogs && testSessionLogs.length > 0) {
      const formatted = formatLogsForContext(testSessionLogs)
      // Check if the formatted logs are still in the input message
      if (!inputMessage.includes(formatted)) {
        setLogsAppended(false)
      }
    }
  }, [inputMessage, logsAppended, testSessionLogs])

  // Check message count and show clear chat suggestion
  useEffect(() => {
    if (!projectId) return

    const localStorageKey = `chromie-clear-chat-suggestion-shown-${projectId}`
    const hasShownSuggestion = typeof window !== 'undefined' && localStorage.getItem(localStorageKey) === 'true'

    // Show modal when messages exceed 5 and not currently generating and haven't shown before
    if (messages.length > 5 && !isGenerating && !hasShownSuggestion) {
      setShowClearChatSuggestion(true)
      // Mark as shown so it doesn't appear again for this project
      if (typeof window !== 'undefined') {
        localStorage.setItem(localStorageKey, 'true')
      }
    }
  }, [messages.length, isGenerating, projectId])

  // Auto-scroll to the beginning of AI messages when they're received
  useEffect(() => {
    const assistantMessages = messages.filter(m => m.role === 'assistant')
    const currentAssistantCount = assistantMessages.length

    // Check if a new assistant message was added
    if (currentAssistantCount > lastAssistantMessageCountRef.current) {
      // Find the container with the scrollable content
      const scrollContainer = messagesContainerRef.current?.querySelector('[data-scroll-container]')

      if (scrollContainer) {
        // Find all assistant message elements
        const messageElements = scrollContainer.querySelectorAll('[data-message-role="assistant"]')

        if (messageElements.length > 0) {
          // Get the last (most recent) assistant message element
          const lastAssistantElement = messageElements[messageElements.length - 1]

          // Scroll to the top of this message with smooth behavior
          lastAssistantElement.scrollIntoView({
            behavior: 'smooth',
            block: 'start',
            inline: 'nearest'
          })
        }
      }

      // Update the ref to track current count
      lastAssistantMessageCountRef.current = currentAssistantCount
    }
  }, [messages])

  // Note: URL and API prompts are now handled as chat messages, not modals

  const handleSendMessage = async (value, withSearch, images, taggedFiles) => {
    if ((!value.trim() && (!images || images.length === 0)) || isGenerating) return

    // Convert File objects to data URLs for consistent storage
    let imageDataUrls = []
    if (images && images.length > 0) {
      imageDataUrls = await Promise.all(
        images.map(async (image) => {
          if (image instanceof File) {
            return new Promise((resolve) => {
              const reader = new FileReader()
              reader.onloadend = () => resolve(reader.result)
              reader.readAsDataURL(image)
            })
          }
          return image // Already a data URL
        })
      )
    }

    // Fetch file contents from flatFiles for tagged files
    let taggedFilesWithContent = []
    if (taggedFiles && taggedFiles.length > 0 && flatFiles) {
      taggedFilesWithContent = taggedFiles.map(tag => {
        const fileData = flatFiles.find(f => f.file_path === tag.path)
        return {
          path: tag.path,
          name: tag.name,
          content: fileData?.content || ''
        }
      })
    }

    const userMessage = {
      role: "user",
      content: value,
      images: imageDataUrls.length > 0 ? imageDataUrls : undefined,
      taggedFiles: taggedFilesWithContent.length > 0 ? taggedFilesWithContent : undefined,
    }

    setMessages((prev) => [...prev, userMessage])
    setInputMessage("")

    // Clear logs after message is sent if they were appended
    if (logsAppended && testSessionLogs) {
      onClearTestSessionLogs?.()
    }
    setLogsAppended(false)

    // When no code has been generated yet, always use the agent flow (initial generation).
    const mode =
      effectiveHasGeneratedCode && followUpMode ? followUpMode : "agent"

    if (mode === "ask") {
      // Ask mode: answer questions using existing project code only, no edits.
      if (!projectId) {
        console.error("[streaming-chat] Ask mode requires a projectId")
        return
      }

      try {
        chatState.setIsGenerating(true)
        const res = await fetch(`/api/projects/${projectId}/ask`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            question: value,
            taggedFiles: taggedFilesWithContent
          }),
        })

        if (!res.ok) {
          const errorData = await res.json().catch(() => ({}))
          const message =
            errorData?.error ||
            `Ask request failed with status ${res.status}`
          console.error("[streaming-chat] Ask mode error:", message)
          setMessages((prev) => [
            ...prev,
            {
              role: "assistant",
              content:
                "I couldn't answer that question right now. Please try again or switch back to agent mode.",
            },
          ])
          return
        }

        const data = await res.json()
        const answer =
          data?.answer ||
          "I wasn't able to generate an answer. Please try asking in a different way."

        setMessages((prev) => [
          ...prev,
          {
            role: "assistant",
            content: answer,
          },
        ])
      } catch (err) {
        console.error("[streaming-chat] Ask mode unexpected error:", err)
        setMessages((prev) => [
          ...prev,
          {
            role: "assistant",
            content:
              "Something went wrong while answering that question. Please try again.",
          },
        ])
      } finally {
        chatState.setIsGenerating(false)
      }
    } else {
      // Agent mode: existing behavior (new extension or add-to-existing with edits).
      await startGeneration(value, false, images, taggedFilesWithContent)
    }
  }

  const handleAppendLogs = () => {
    if (!testSessionLogs || logsAppended) return

    const formatted = formatLogsForContext(testSessionLogs)
    const currentValue = inputMessage.trim()

    // Add separator if there's existing content
    const separator = currentValue ? '\n\n' : ''
    const newValue = currentValue + separator + formatted

    setInputMessage(newValue)
    setLogsAppended(true)
  }

  const handleUrlSubmit = async (userUrl) => {
    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      const skipScrapingSelection = userUrl === null
      lastUrlSelectionRef.current = {
        userUrl,
        skipScraping: skipScrapingSelection,
      }
    }

    currentRequestRef.current = null

    if (requestInfo) {
      if (userUrl === null) {
        await continueGenerationWithSkipScraping(requestInfo)
      } else {
        await startGenerationWithUrl(
          requestInfo.prompt,
          userUrl,
          requestInfo.requestType,
          requestInfo.projectId,
          requestInfo.analysisData
        )
      }
    }
  }

  const handleUrlCancel = () => {
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
    lastUrlSelectionRef.current = null
  }

  const handleApiSubmit = async (userApis) => {
    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      await continueGenerationWithApis(requestInfo, userApis)
      currentRequestRef.current = null
    }
  }

  const handleApiCancel = () => {
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
  }

  const handleClearConversation = async () => {
    await clearConversation()
  }

  return (
    <div className="flex flex-col h-full relative">
      {/* Chat Header */}
      <div className="pt-4 pb-2 px-8 max-w-7xl mx-auto w-full flex items-center justify-between">
        <p className="text-sm text-gray-200 font-bold">
          {projectName || "describe what you want to add or modify"}
        </p>
        {messages.length > 1 && !isGenerating && (
          <button
            onClick={handleClearConversation}
            className="flex items-center space-x-1.5 px-3 py-1.5 text-xs text-gray-400 hover:text-white hover:bg-gray-800/50 rounded-lg transition-colors"
            title="Clear conversation (keeps code)"
          >
            <Trash2 className="h-3.5 w-3.5" />
            <span>clear chat</span>
          </button>
        )}
      </div>

      {/* Messages */}
      <div ref={messagesContainerRef} className="flex-1 overflow-hidden pb-4">
        <Conversation>
          <ConversationContent smooth={true} className="custom-scrollbar" data-scroll-container>
            {messages
              .filter((message) => !message.isThinking)
              .map((message, index, filteredMessages) => {
                // Show avatar only on first AI message in succession
                const prevMessage = index > 0 ? filteredMessages[index - 1] : null
                const showAvatar = message.role === "assistant" &&
                  (!prevMessage || prevMessage.role !== "assistant")

                return (
                  <div key={index} data-message-role={message.role}>
                    <ChatMessage
                      message={message}
                      index={index}
                      showAvatar={showAvatar}
                      typingCancelSignal={chatState.typingCancelSignal}
                      onUrlSubmit={handleUrlSubmit}
                      onApiSubmit={handleApiSubmit}
                      onUrlCancel={handleUrlCancel}
                      onApiCancel={handleApiCancel}
                      setMessages={setMessages}
                      projectId={projectId}
                      onRevert={() => {
                        // Reload the page to refresh the code canvas with reverted files
                        if (typeof window !== 'undefined') {
                          window.location.reload()
                        }
                      }}
                    />
                  </div>
                )
              })}

            {/* Typing indicator */}
            {isGenerating && !(planningProgress && currentPlanningPhase) && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received" isLoading />
              </ChatBubble>
            )}

            {/* Planning progress */}
            {planningProgress && currentPlanningPhase && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center space-x-3">
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-slate-300 rounded-full animate-pulse"
                        style={{ animationDelay: "200ms" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"
                        style={{ animationDelay: "400ms" }}
                      ></div>
                    </div>
                    <div className="flex flex-col">
                      <span className="text-xs text-slate-300 uppercase tracking-wide">
                        {currentPlanningPhase === "analysis" && "Planning"}
                        {currentPlanningPhase === "documentation" && "Documentation"}
                        {currentPlanningPhase === "scraping" && "Web Analysis"}
                        {!["analysis", "documentation", "scraping"].includes(currentPlanningPhase) && "Planning"}
                      </span>
                      <span className="text-sm text-white font-medium">{planningProgress}</span>
                    </div>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}

            {/* Model Thinking Panel */}
            {(() => {
              const hasContent = !!(modelThinkingDisplay || modelThinkingFull)
              const forceShow = thinkingChunkCountRef.current > 0
              const shouldShow = (hasContent || forceShow) && !isGenerationComplete

              // Extract the latest thinking phase title from the model thinking content
              const extractLatestPhase = (text) => {
                if (!text) return null
                // Match all text between ** markers
                const matches = text.match(/\*\*(.*?)\*\*/g)
                if (!matches || matches.length === 0) return null
                // Get the last match and remove the ** markers
                const lastMatch = matches[matches.length - 1]
                return lastMatch.replace(/\*\*/g, '').trim()
              }

              const currentPhase = extractLatestPhase(modelThinkingFull || modelThinkingDisplay)

              return shouldShow
            })() && (
              <div className="mt-2">
                <button
                  type="button"
                  className="flex items-center justify-between w-full text-left bg-slate-800/40 hover:bg-slate-800/60 border border-slate-600/40 px-3 py-2.5 rounded"
                  onClick={() => setIsModelThinkingOpen(!isModelThinkingOpen)}
                  aria-expanded={isModelThinkingOpen}
                >
                  <div className="flex flex-col gap-0.5">
                    <span className="text-xs uppercase tracking-wide text-slate-400">Reasoning</span>
                    <span className="text-sm font-medium text-slate-200">
                      {(() => {
                        const extractLatestPhase = (text) => {
                          if (!text) return null
                          const matches = text.match(/\*\*(.*?)\*\*/g)
                          if (!matches || matches.length === 0) return null
                          const lastMatch = matches[matches.length - 1]
                          return lastMatch.replace(/\*\*/g, '').trim()
                        }

                        const currentPhase = extractLatestPhase(modelThinkingFull || modelThinkingDisplay)
                        const chunkCount = thinkingChunkCountRef.current

                        if (currentPhase) {
                          return `${currentPhase} (${chunkCount} ${chunkCount === 1 ? 'chunk' : 'chunks'})`
                        }
                        return "Analyzing request and planning implementation"
                      })()}
                    </span>
                  </div>
                  {isModelThinkingOpen ? (
                    <ChevronDown className="h-4 w-4 text-slate-400 flex-shrink-0" />
                  ) : (
                    <ChevronRight className="h-4 w-4 text-slate-400 flex-shrink-0" />
                  )}
                </button>
                {isModelThinkingOpen && (
                  <div className="mt-2 p-3 rounded-lg border border-slate-500/20 bg-slate-800/20">
                    <div className="text-xs text-slate-400 mb-2">
                      Detailed reasoning :
                    </div>
                    <div className="text-white text-sm whitespace-pre-wrap leading-relaxed max-h-48 overflow-auto italic">
                      {modelThinkingDisplay || modelThinkingFull}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Open Canvas Button */}
            {effectiveHasGeneratedCode && onOpenCanvas && !isCanvasOpen && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center justify-between gap-4">
                    <div className="flex items-center gap-3 flex-1 min-w-0">
                      <div className="flex-shrink-0 w-8 h-8 rounded-lg bg-gray-600 flex items-center justify-center">
                        <FileCode className="h-4 w-4 text-white" />
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-white truncate">
                          {projectName || "Chrome Extension"}
                        </div>
                        <div className="text-xs text-slate-400">
                          {isGenerating ? "Generating code..." : "Code generated successfully"}
                        </div>
                      </div>
                    </div>
                    <button
                      id="tour-open-canvas-button"
                      onClick={() => onOpenCanvas()}
                      className="flex-shrink-0 px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg"
                    >
                      Open
                    </button>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>
      </div>

      {/* Input at bottom */}
      <div className="px-4 pb-6 pt-4">
        <div
          className={cn(
            "w-full max-w-4xl mx-auto",
            isCanvasOpen ? "pl-[16.67%]" : ""
          )}
        >
          <div className="relative">
            <AIInputWithSearch
              placeholder={
                effectiveHasGeneratedCode && followUpMode === "ask"
                  ? projectName
                    ? `ask a question about ${projectName}...`
                    : "ask a question about this extension..."
                  : projectName
                    ? `describe what you want to add or modify in ${projectName}...`
                    : "describe what you want to add or modify..."
              }
              value={inputMessage}
              onChange={(value) => setInputMessage(value)}
              onSubmit={async (value, withSearch, images, taggedFiles) =>
                await handleSendMessage(value, withSearch, images, taggedFiles)
              }
              disabled={isGenerating || !projectId}
              className="py-0"
              enableImageUpload={effectiveHasGeneratedCode}
              availableFiles={flatFiles || []}
              enableFileTagging={true}
              extraControlsLeft={
                effectiveHasGeneratedCode ? (
                  <div className="pointer-events-auto flex items-center gap-2">
                    <div className="flex items-center gap-1 rounded-full bg-gray-900/80 border border-gray-700 px-1 py-0.5 text-[11px]">
                      <button
                        type="button"
                        onClick={() => setFollowUpMode("agent")}
                        className={`px-2 py-0.5 rounded-full transition-colors ${
                          followUpMode === "agent"
                            ? "bg-gray-100 text-black"
                            : "text-gray-400 hover:text-white"
                        }`}
                      >
                        agent
                      </button>
                      <button
                        type="button"
                        onClick={() => setFollowUpMode("ask")}
                        className={`px-2 py-0.5 rounded-full transition-colors ${
                          followUpMode === "ask"
                            ? "bg-gray-100 text-black"
                            : "text-gray-400 hover:text-white"
                        }`}
                      >
                        ask
                      </button>
                    </div>
                    {testSessionLogs && testSessionLogs.length > 0 && (
                      <LogsAppendButton
                        logs={testSessionLogs}
                        onAppend={handleAppendLogs}
                        disabled={logsAppended || isGenerating}
                      />
                    )}
                  </div>
                ) : testSessionLogs && testSessionLogs.length > 0 ? (
                  <LogsAppendButton
                    logs={testSessionLogs}
                    onAppend={handleAppendLogs}
                    disabled={logsAppended || isGenerating}
                  />
                ) : null
              }
            />
          </div>
        </div>
      </div>

      {/* Token Usage Alert Modal */}
      <TokenUsageAlert isOpen={showTokenLimitModal} onClose={() => setShowTokenLimitModal(false)} />

      {/* Clear Chat Suggestion Modal */}
      <ClearChatSuggestionModal
        isOpen={showClearChatSuggestion}
        onClose={() => setShowClearChatSuggestion(false)}
        onClearChat={handleClearConversation}
        projectName={projectName}
      />
    </div>
  )
}
