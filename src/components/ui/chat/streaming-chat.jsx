"use client"

import { useEffect, useState } from "react"
import { FileCode, ChevronDown, ChevronRight, Trash2 } from "lucide-react"
import { AIInputWithSearch } from "@/components/ui/ai-input-with-search"
import TokenUsageAlert from "@/components/ui/modals/token-usage-alert"
import ClearChatSuggestionModal from "@/components/ui/modals/clear-chat-suggestion-modal"
import ChatMessage from "@/components/ui/chat/chat-message"
import { ChatBubble, ChatBubbleMessage, ChatBubbleAvatar } from "@/components/ui/chat-bubble"
import { Conversation, ConversationContent, ConversationScrollButton } from "@/components/ui/conversation"
import { useChatState } from "./hooks/useChatState"
import { useStreamProcessor } from "./hooks/useStreamProcessor"
import { cn } from "@/lib/utils"
import ConsoleLogsContextPill from "@/components/ui/chat/console-logs-context-pill"

export default function StreamingChat({
  projectId,
  projectName,
  autoGeneratePrompt,
  onAutoGenerateComplete,
  onCodeGenerated,
  onGenerationStart,
  onGenerationEnd,
  onOpenCanvas,
  hasGeneratedCode: hasGeneratedCodeProp,
  isCanvasOpen,
  chatWidth,
  isProjectReady,
  isOnboardingModalOpen,
  modelOverride,
  onCodeGenerationStarting,
  onSetInputMessage,
  testSessionLogs,
  onClearTestSessionLogs,
}) {
  const chatState = useChatState(projectId, hasGeneratedCodeProp)
  const {
    inputMessage,
    setInputMessage,
    messages,
    setMessages,
    isGenerating,
    effectiveHasGeneratedCode,
    showTokenLimitModal,
    setShowTokenLimitModal,
    autoGeneratedRef,
    currentRequestRef,
    lastUrlSelectionRef,
    hasGeneratedCode,
    isModelThinkingOpen,
    setIsModelThinkingOpen,
    modelThinkingDisplay,
    modelThinkingFull,
    isGenerationComplete,
    thinkingChunkCountRef,
    planningProgress,
    currentPlanningPhase,
    isActuallyGeneratingCode,
    clearConversation,
  } = chatState

  // State for clear chat suggestion modal
  const [showClearChatSuggestion, setShowClearChatSuggestion] = useState(false)

  const { startGeneration, startGenerationWithUrl, continueGenerationWithSkipScraping, continueGenerationWithApis } =
    useStreamProcessor({
      chatState,
      projectId,
      modelOverride,
      isOnboardingModalOpen,
      onGenerationStart,
      onGenerationEnd,
      onCodeGenerated,
      onAutoGenerateComplete,
      autoGeneratePrompt,
    })

  // Auto-generation effect
  useEffect(() => {
    if (
      autoGeneratePrompt &&
      isProjectReady &&
      !hasGeneratedCode &&
      !isGenerating &&
      !autoGeneratedRef.current
    ) {
      autoGeneratedRef.current = true
      setInputMessage(autoGeneratePrompt)

      const userMessage = {
        role: "user",
        content: autoGeneratePrompt,
      }
      setMessages((prev) => [...prev, userMessage])
      startGeneration(autoGeneratePrompt, true)
    }
  }, [autoGeneratePrompt, isProjectReady, hasGeneratedCode, isGenerating])

  // Notify parent when actual code generation starts
  useEffect(() => {
    if (isActuallyGeneratingCode && onCodeGenerationStarting) {
      onCodeGenerationStarting()
    }
  }, [isActuallyGeneratingCode, onCodeGenerationStarting])

  // Expose setInputMessage to parent component
  useEffect(() => {
    if (onSetInputMessage) {
      onSetInputMessage(setInputMessage)
    }
  }, [onSetInputMessage, setInputMessage])

  // Check message count and show clear chat suggestion
  useEffect(() => {
    if (!projectId) return

    const localStorageKey = `chromie-clear-chat-suggestion-shown-${projectId}`
    const hasShownSuggestion = typeof window !== 'undefined' && localStorage.getItem(localStorageKey) === 'true'

    // Show modal when messages exceed 5 and not currently generating and haven't shown before
    if (messages.length > 5 && !isGenerating && !hasShownSuggestion) {
      setShowClearChatSuggestion(true)
      // Mark as shown so it doesn't appear again for this project
      if (typeof window !== 'undefined') {
        localStorage.setItem(localStorageKey, 'true')
      }
    }
  }, [messages.length, isGenerating, projectId])

  // Note: URL and API prompts are now handled as chat messages, not modals

  const handleSendMessage = async (value, withSearch, images) => {
    if ((!value.trim() && (!images || images.length === 0)) || isGenerating) return

    // Convert File objects to data URLs for consistent storage
    let imageDataUrls = []
    if (images && images.length > 0) {
      imageDataUrls = await Promise.all(
        images.map(async (image) => {
          if (image instanceof File) {
            return new Promise((resolve) => {
              const reader = new FileReader()
              reader.onloadend = () => resolve(reader.result)
              reader.readAsDataURL(image)
            })
          }
          return image // Already a data URL
        })
      )
    }

    const userMessage = {
      role: "user",
      content: value,
      images: imageDataUrls.length > 0 ? imageDataUrls : undefined,
    }

    setMessages((prev) => [...prev, userMessage])
    setInputMessage("")
    await startGeneration(value, false, images)
  }

  const handleUrlSubmit = async (userUrl) => {
    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      const skipScrapingSelection = userUrl === null
      lastUrlSelectionRef.current = {
        userUrl,
        skipScraping: skipScrapingSelection,
      }
    }

    currentRequestRef.current = null

    if (requestInfo) {
      if (userUrl === null) {
        await continueGenerationWithSkipScraping(requestInfo)
      } else {
        await startGenerationWithUrl(
          requestInfo.prompt,
          userUrl,
          requestInfo.requestType,
          requestInfo.projectId,
          requestInfo.analysisData
        )
      }
    }
  }

  const handleUrlCancel = () => {
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
    lastUrlSelectionRef.current = null
  }

  const handleApiSubmit = async (userApis) => {
    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      await continueGenerationWithApis(requestInfo, userApis)
      currentRequestRef.current = null
    }
  }

  const handleApiCancel = () => {
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
  }

  const handleClearConversation = async () => {
    await clearConversation()
  }

  return (
    <div className="flex flex-col h-full relative">
      {/* Chat Header */}
      <div className="pt-4 pb-2 px-8 max-w-7xl mx-auto w-full flex items-center justify-between">
        <p className="text-sm text-gray-200 font-bold">{projectName || "describe what you want to add or modify"}</p>
        {messages.length > 1 && !isGenerating && (
          <button
            onClick={handleClearConversation}
            className="flex items-center space-x-1.5 px-3 py-1.5 text-xs text-gray-400 hover:text-white hover:bg-gray-800/50 rounded-lg transition-colors"
            title="Clear conversation (keeps code)"
          >
            <Trash2 className="h-3.5 w-3.5" />
            <span>clear chat</span>
          </button>
        )}
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-hidden pb-4">
        <Conversation>
          <ConversationContent smooth={true} className="custom-scrollbar">
            {messages
              .filter((message) => !message.isThinking)
              .map((message, index, filteredMessages) => {
                // Show avatar only on first AI message in succession
                const prevMessage = index > 0 ? filteredMessages[index - 1] : null
                const showAvatar = message.role === "assistant" &&
                  (!prevMessage || prevMessage.role !== "assistant")

                return (
                  <ChatMessage
                    key={index}
                    message={message}
                    index={index}
                    showAvatar={showAvatar}
                    typingCancelSignal={chatState.typingCancelSignal}
                    onUrlSubmit={handleUrlSubmit}
                    onApiSubmit={handleApiSubmit}
                    onUrlCancel={handleUrlCancel}
                    onApiCancel={handleApiCancel}
                    setMessages={setMessages}
                    projectId={projectId}
                    onRevert={() => {
                      // Reload the page to refresh the code canvas with reverted files
                      if (typeof window !== 'undefined') {
                        window.location.reload()
                      }
                    }}
                  />
                )
              })}

            {/* Typing indicator */}
            {isGenerating && !(planningProgress && currentPlanningPhase) && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received" isLoading />
              </ChatBubble>
            )}

            {/* Planning progress */}
            {planningProgress && currentPlanningPhase && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center space-x-3">
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-slate-300 rounded-full animate-pulse"
                        style={{ animationDelay: "200ms" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"
                        style={{ animationDelay: "400ms" }}
                      ></div>
                    </div>
                    <div className="flex flex-col">
                      <span className="text-xs text-slate-300 uppercase tracking-wide">
                        {currentPlanningPhase === "analysis" && "Planning"}
                        {currentPlanningPhase === "documentation" && "Documentation"}
                        {currentPlanningPhase === "scraping" && "Web Analysis"}
                        {!["analysis", "documentation", "scraping"].includes(currentPlanningPhase) && "Planning"}
                      </span>
                      <span className="text-sm text-white font-medium">{planningProgress}</span>
                    </div>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}

            {/* Model Thinking Panel */}
            {(() => {
              const hasContent = !!(modelThinkingDisplay || modelThinkingFull)
              const forceShow = thinkingChunkCountRef.current > 0
              const shouldShow = (hasContent || forceShow) && !isGenerationComplete

              // Extract the latest thinking phase title from the model thinking content
              const extractLatestPhase = (text) => {
                if (!text) return null
                // Match all text between ** markers
                const matches = text.match(/\*\*(.*?)\*\*/g)
                if (!matches || matches.length === 0) return null
                // Get the last match and remove the ** markers
                const lastMatch = matches[matches.length - 1]
                return lastMatch.replace(/\*\*/g, '').trim()
              }

              const currentPhase = extractLatestPhase(modelThinkingFull || modelThinkingDisplay)

              return shouldShow
            })() && (
              <div className="mt-2">
                <button
                  type="button"
                  className="flex items-center justify-between w-full text-left bg-slate-800/40 hover:bg-slate-800/60 border border-slate-600/40 px-3 py-2.5 rounded"
                  onClick={() => setIsModelThinkingOpen(!isModelThinkingOpen)}
                  aria-expanded={isModelThinkingOpen}
                >
                  <div className="flex flex-col gap-0.5">
                    <span className="text-xs uppercase tracking-wide text-slate-400">Reasoning</span>
                    <span className="text-sm font-medium text-slate-200">
                      {(() => {
                        const extractLatestPhase = (text) => {
                          if (!text) return null
                          const matches = text.match(/\*\*(.*?)\*\*/g)
                          if (!matches || matches.length === 0) return null
                          const lastMatch = matches[matches.length - 1]
                          return lastMatch.replace(/\*\*/g, '').trim()
                        }

                        const currentPhase = extractLatestPhase(modelThinkingFull || modelThinkingDisplay)
                        const chunkCount = thinkingChunkCountRef.current

                        if (currentPhase) {
                          return `${currentPhase} (${chunkCount} ${chunkCount === 1 ? 'chunk' : 'chunks'})`
                        }
                        return "Analyzing request and planning implementation"
                      })()}
                    </span>
                  </div>
                  {isModelThinkingOpen ? (
                    <ChevronDown className="h-4 w-4 text-slate-400 flex-shrink-0" />
                  ) : (
                    <ChevronRight className="h-4 w-4 text-slate-400 flex-shrink-0" />
                  )}
                </button>
                {isModelThinkingOpen && (
                  <div className="mt-2 p-3 rounded-lg border border-slate-500/20 bg-slate-800/20">
                    <div className="text-xs text-slate-400 mb-2">
                      Detailed reasoning :
                    </div>
                    <div className="text-white text-sm whitespace-pre-wrap leading-relaxed max-h-48 overflow-auto italic">
                      {modelThinkingDisplay || modelThinkingFull}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Open Canvas Button */}
            {effectiveHasGeneratedCode && onOpenCanvas && !isGenerating && !isCanvasOpen && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center justify-between gap-4">
                    <div className="flex items-center gap-3 flex-1 min-w-0">
                      <div className="flex-shrink-0 w-8 h-8 rounded-lg bg-gray-600 flex items-center justify-center">
                        <FileCode className="h-4 w-4 text-white" />
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-white truncate">
                          {projectName || "Chrome Extension"}
                        </div>
                        <div className="text-xs text-slate-400">Code generated successfully</div>
                      </div>
                    </div>
                    <button
                      id="tour-open-canvas-button"
                      onClick={() => onOpenCanvas()}
                      className="flex-shrink-0 px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg"
                    >
                      Open
                    </button>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>
      </div>

      {/* Input at bottom */}
      <div className="px-4 pb-6 pt-4">
        <div className={cn(
          "w-full max-w-4xl mx-auto",
          isCanvasOpen ? "pl-[16.67%]" : ""
        )}>
          {/* Console Logs Context Pill */}
          {testSessionLogs && testSessionLogs.length > 0 && (
            <ConsoleLogsContextPill
              logs={testSessionLogs}
              onAddToContext={(formatted) => {
                setInputMessage(formatted)
                onClearTestSessionLogs?.()
              }}
              onDismiss={() => onClearTestSessionLogs?.()}
            />
          )}
          <AIInputWithSearch
            placeholder={
              projectName
                ? `describe what you want to add or modify in ${projectName}...`
                : "describe what you want to add or modify..."
            }
            value={inputMessage}
            onChange={(value) => setInputMessage(value)}
            onSubmit={async (value, withSearch, images) => await handleSendMessage(value, withSearch, images)}
            disabled={isGenerating || !projectId}
            className="py-0"
            enableImageUpload={effectiveHasGeneratedCode}
          />
        </div>
      </div>

      {/* Token Usage Alert Modal */}
      <TokenUsageAlert isOpen={showTokenLimitModal} onClose={() => setShowTokenLimitModal(false)} />

      {/* Clear Chat Suggestion Modal */}
      <ClearChatSuggestionModal
        isOpen={showClearChatSuggestion}
        onClose={() => setShowClearChatSuggestion(false)}
        onClearChat={handleClearConversation}
        projectName={projectName}
      />
    </div>
  )
}
