"use client"

import { useEffect } from "react"
import { FileCode, ChevronDown, ChevronRight } from "lucide-react"
import { AIInputWithSearch } from "@/components/ui/ai-input-with-search"
import ModalUrlPrompt from "@/components/ui/modals/modal-url-prompt"
import ModalApiPrompt from "@/components/ui/modals/modal-api-prompt"
import TokenUsageAlert from "@/components/ui/modals/token-usage-alert"
import ChatMessage from "@/components/ui/chat/chat-message"
import { ChatBubble, ChatBubbleMessage, ChatBubbleAvatar } from "@/components/ui/chat-bubble"
import { Conversation, ConversationContent, ConversationScrollButton } from "@/components/ui/conversation"
import { useChatState } from "./hooks/useChatState"
import { useStreamProcessor } from "./hooks/useStreamProcessor"
import { cn } from "@/lib/utils"

export default function StreamingChat({
  projectId,
  projectName,
  autoGeneratePrompt,
  onAutoGenerateComplete,
  onCodeGenerated,
  onGenerationStart,
  onGenerationEnd,
  onOpenCanvas,
  hasGeneratedCode: hasGeneratedCodeProp,
  isCanvasOpen,
  chatWidth,
  isProjectReady,
  isOnboardingModalOpen,
  modelOverride,
}) {
  const chatState = useChatState(projectId, hasGeneratedCodeProp)
  const {
    inputMessage,
    setInputMessage,
    messages,
    setMessages,
    isGenerating,
    effectiveHasGeneratedCode,
    urlPromptData,
    setUrlPromptData,
    showUrlPrompt,
    setShowUrlPrompt,
    apiPromptData,
    setApiPromptData,
    showApiPrompt,
    setShowApiPrompt,
    showTokenLimitModal,
    setShowTokenLimitModal,
    pendingUrlPrompt,
    setPendingUrlPrompt,
    pendingApiPrompt,
    setPendingApiPrompt,
    autoGeneratedRef,
    currentRequestRef,
    lastUrlSelectionRef,
    hasGeneratedCode,
    isModelThinkingOpen,
    setIsModelThinkingOpen,
    modelThinkingDisplay,
    modelThinkingFull,
    isGenerationComplete,
    thinkingChunkCountRef,
    planningProgress,
    currentPlanningPhase,
  } = chatState

  const { startGeneration, startGenerationWithUrl, continueGenerationWithSkipScraping, continueGenerationWithApis } =
    useStreamProcessor({
      chatState,
      projectId,
      modelOverride,
      isOnboardingModalOpen,
      onGenerationStart,
      onGenerationEnd,
      onCodeGenerated,
      onAutoGenerateComplete,
      autoGeneratePrompt,
    })

  // Auto-generation effect
  useEffect(() => {
    if (
      autoGeneratePrompt &&
      isProjectReady &&
      !hasGeneratedCode &&
      !isGenerating &&
      !autoGeneratedRef.current
    ) {
      autoGeneratedRef.current = true
      setInputMessage(autoGeneratePrompt)

      const userMessage = {
        role: "user",
        content: autoGeneratePrompt,
      }
      setMessages((prev) => [...prev, userMessage])
      startGeneration(autoGeneratePrompt, true)
    }
  }, [autoGeneratePrompt, isProjectReady, hasGeneratedCode, isGenerating])

  // Watch for onboarding close and show pending modals
  useEffect(() => {
    if (!isOnboardingModalOpen) {
      if (pendingUrlPrompt) {
        console.log("✅ Onboarding closed - showing pending URL prompt modal")
        setUrlPromptData(pendingUrlPrompt)
        setShowUrlPrompt(true)
        setPendingUrlPrompt(null)
      } else if (pendingApiPrompt) {
        console.log("✅ Onboarding closed - showing pending API prompt modal")
        setApiPromptData(pendingApiPrompt)
        setShowApiPrompt(true)
        setPendingApiPrompt(null)
      }
    }
  }, [isOnboardingModalOpen, pendingUrlPrompt, pendingApiPrompt])

  const handleSendMessage = async (value) => {
    if (!value.trim() || isGenerating) return

    const userMessage = {
      role: "user",
      content: value,
    }

    setMessages((prev) => [...prev, userMessage])
    setInputMessage("")
    await startGeneration(value, false)
  }

  const handleUrlSubmit = async (data, userUrl, originalPrompt) => {
    setShowUrlPrompt(false)
    setUrlPromptData(null)

    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      const skipScrapingSelection = userUrl === null
      lastUrlSelectionRef.current = {
        userUrl,
        skipScraping: skipScrapingSelection,
      }
    }

    currentRequestRef.current = null

    if (requestInfo) {
      if (userUrl === null) {
        await continueGenerationWithSkipScraping(requestInfo)
      } else {
        await startGenerationWithUrl(
          requestInfo.prompt,
          userUrl,
          requestInfo.requestType,
          requestInfo.projectId,
          requestInfo.analysisData
        )
      }
    }
  }

  const handleUrlCancel = () => {
    setShowUrlPrompt(false)
    setUrlPromptData(null)
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
    lastUrlSelectionRef.current = null
  }

  const handleApiSubmit = async (data, userApis, originalPrompt) => {
    setShowApiPrompt(false)
    setApiPromptData(null)

    const requestInfo = currentRequestRef.current
    if (requestInfo) {
      await continueGenerationWithApis(requestInfo, userApis)
      currentRequestRef.current = null
    }
  }

  const handleApiCancel = () => {
    setShowApiPrompt(false)
    setApiPromptData(null)
    chatState.setIsGenerating(false)
    currentRequestRef.current = null
  }

  return (
    <div className="flex flex-col h-full relative">
      {/* Chat Header */}
      <div className="pt-4 pb-2">
        <p className="text-sm text-gray-400 pl-[16.67%]">{projectName || "describe what you want to add or modify"}</p>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-hidden pb-28">
        <Conversation>
          <ConversationContent smooth={true} className="custom-scrollbar">
            {messages
              .filter((message) => !message.isThinking)
              .map((message, index, filteredMessages) => {
                // Show avatar only on first AI message in succession
                const prevMessage = index > 0 ? filteredMessages[index - 1] : null
                const showAvatar = message.role === "assistant" &&
                  (!prevMessage || prevMessage.role !== "assistant")

                return (
                  <ChatMessage
                    key={index}
                    message={message}
                    index={index}
                    showAvatar={showAvatar}
                    typingCancelSignal={chatState.typingCancelSignal}
                  />
                )
              })}

            {/* Typing indicator */}
            {isGenerating && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received" isLoading />
              </ChatBubble>
            )}

            {/* Planning progress */}
            {planningProgress && currentPlanningPhase && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center space-x-3">
                    <div className="flex space-x-1">
                      <div className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"></div>
                      <div
                        className="w-2 h-2 bg-slate-300 rounded-full animate-pulse"
                        style={{ animationDelay: "200ms" }}
                      ></div>
                      <div
                        className="w-2 h-2 bg-slate-400 rounded-full animate-pulse"
                        style={{ animationDelay: "400ms" }}
                      ></div>
                    </div>
                    <div className="flex flex-col">
                      <span className="text-xs text-slate-300 uppercase tracking-wide">
                        {currentPlanningPhase === "analysis" && "Planning"}
                        {currentPlanningPhase === "documentation" && "Documentation"}
                        {currentPlanningPhase === "scraping" && "Web Analysis"}
                        {!["analysis", "documentation", "scraping"].includes(currentPlanningPhase) && "Planning"}
                      </span>
                      <span className="text-sm text-white font-medium">{planningProgress}</span>
                    </div>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}

            {/* Model Thinking Panel */}
            {(() => {
              const hasContent = !!(modelThinkingDisplay || modelThinkingFull)
              const forceShow = thinkingChunkCountRef.current > 0
              const shouldShow = (hasContent || forceShow) && !isGenerationComplete
              return shouldShow
            })() && (
              <div className="mt-2">
                <button
                  type="button"
                  className="flex items-center justify-between w-full text-left text-xs uppercase tracking-wide text-slate-300 bg-slate-800/40 hover:bg-slate-800/60 border border-slate-600/40 px-3 py-2 rounded"
                  onClick={() => setIsModelThinkingOpen(!isModelThinkingOpen)}
                  aria-expanded={isModelThinkingOpen}
                >
                  <span>Model thoughts ({thinkingChunkCountRef.current} chunks)</span>
                  {isModelThinkingOpen ? (
                    <ChevronDown className="h-3 w-3" />
                  ) : (
                    <ChevronRight className="h-3 w-3" />
                  )}
                </button>
                {isModelThinkingOpen && (
                  <div className="mt-2 p-3 rounded-lg border border-slate-500/20 bg-slate-800/20 text-white text-sm whitespace-pre-wrap leading-relaxed max-h-48 overflow-auto italic">
                    {modelThinkingDisplay || modelThinkingFull}
                  </div>
                )}
              </div>
            )}

            {/* Open Canvas Button */}
            {effectiveHasGeneratedCode && onOpenCanvas && !isGenerating && !isCanvasOpen && (
              <ChatBubble variant="received">
                <ChatBubbleAvatar src="/chromie-logo-1.png" fallback="AI" className="h-8 w-8 shrink-0" />
                <ChatBubbleMessage variant="received">
                  <div className="flex items-center justify-between gap-4">
                    <div className="flex items-center gap-3 flex-1 min-w-0">
                      <div className="flex-shrink-0 w-8 h-8 rounded-lg bg-blue-600 flex items-center justify-center">
                        <FileCode className="h-4 w-4 text-white" />
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-white truncate">
                          {projectName || "Chrome Extension"}
                        </div>
                        <div className="text-xs text-slate-400">Code generated successfully</div>
                      </div>
                    </div>
                    <button
                      onClick={() => onOpenCanvas()}
                      className="flex-shrink-0 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg"
                    >
                      Open
                    </button>
                  </div>
                </ChatBubbleMessage>
              </ChatBubble>
            )}
          </ConversationContent>
          <ConversationScrollButton />
        </Conversation>
      </div>

      {/* Floating Input */}
      <div
        className={cn(
          "fixed bottom-6 z-50 px-4",
          isCanvasOpen ? "left-0 right-auto" : "left-0 right-0"
        )}
        style={isCanvasOpen && chatWidth ? { width: `${chatWidth}%` } : undefined}
      >
        <div className={cn(
          isCanvasOpen ? "pl-[16.67%]" : ""
        )}>
          <AIInputWithSearch
            placeholder={
              projectName
                ? `describe what you want to add or modify in ${projectName}...`
                : "describe what you want to add or modify..."
            }
            value={inputMessage}
            onChange={(value) => setInputMessage(value)}
            onSubmit={async (value) => await handleSendMessage(value)}
            disabled={isGenerating || !projectId}
            className="py-0"
          />
        </div>
      </div>

      {/* URL Prompt Modal */}
      {showUrlPrompt && urlPromptData && (
        <ModalUrlPrompt
          data={urlPromptData.data}
          originalPrompt={urlPromptData.originalPrompt}
          onUrlSubmit={handleUrlSubmit}
          onCancel={handleUrlCancel}
          onCodeGenerated={onCodeGenerated}
          projectId={projectId}
          hasGeneratedCode={hasGeneratedCode}
          onGenerationEnd={onGenerationEnd}
        />
      )}

      {/* API Prompt Modal */}
      {showApiPrompt && apiPromptData && (
        <ModalApiPrompt
          data={apiPromptData.data}
          originalPrompt={apiPromptData.originalPrompt}
          onApiSubmit={handleApiSubmit}
          onCancel={handleApiCancel}
        />
      )}

      {/* Token Usage Alert Modal */}
      <TokenUsageAlert isOpen={showTokenLimitModal} onClose={() => setShowTokenLimitModal(false)} />
    </div>
  )
}
